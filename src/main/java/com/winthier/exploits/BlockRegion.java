package com.winthier.exploits;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.Value;
import org.bukkit.Bukkit;
import org.bukkit.block.Block;
import org.bukkit.configuration.file.YamlConfiguration;

@Getter @RequiredArgsConstructor
final class BlockRegion {
    @Value
    static final class Vector {
        private final int x, z;

        static int ofChunk(int v) {
            if (v < 0) {
                return (v + 1) / 32 - 1;
            } else {
                return v / 32;
            }
        }

        static Vector of(BlockChunk.Vector chunk) {
            return new Vector(ofChunk(chunk.getX()), ofChunk(chunk.getZ()));
        }
    }

    static final String FOLDER = "winthier.player_placed_blocks";
    static final Comparator<BlockRegion> LAST_SAVE_COMPARATOR = new Comparator<BlockRegion>() {
        @Override
        public int compare(BlockRegion a, BlockRegion b) {
            return Long.compare(a.lastSave, b.lastSave);
        }
    };
    private final ExploitsPlugin plugin;
    private final BlockWorld blockWorld;
    private final Vector position;
    private final Map<BlockChunk.Vector, BlockChunk> chunks = new HashMap<>();
    @Setter private long lastSave = 0;
    @Setter private long lastUsed = 0;
    @Setter private boolean dirty;

    BlockChunk getBlockChunk(BlockChunk.Vector chunkPosition) {
        BlockChunk result = chunks.get(chunkPosition);
        if (result == null) {
            result = new BlockChunk(blockWorld, this, chunkPosition);
            chunks.put(chunkPosition, result);
        }
        return result;
    }

    BlockChunk getBlockChunk(Block block) {
        return getBlockChunk(BlockChunk.Vector.of(block));
    }

    String getFileName() {
        return String.format("region.%d.%d.yml", position.x, position.z);
    }

    void load() {
        File dir = new File(blockWorld.getWorldFolder(), FOLDER);
        if (!dir.isDirectory()) return;
        File file = new File(dir, getFileName());
        if (!file.isFile()) return;
        YamlConfiguration yaml = YamlConfiguration.loadConfiguration(file);
        for (Map<?, ?> chunkMap: yaml.getMapList("chunks")) {
            @SuppressWarnings("unchecked")
            int x = (Integer)chunkMap.get("x");
            @SuppressWarnings("unchecked")
            int y = (Integer)chunkMap.get("y");
            @SuppressWarnings("unchecked")
            int z = (Integer)chunkMap.get("z");
            @SuppressWarnings("unchecked")
            List<Number> longList = (List<Number>)chunkMap.get("v");
            long[] array = new long[longList.size()];
            for (int i = 0; i < array.length; i += 1) array[i] = longList.get(i).longValue();
            BitSet bits = BitSet.valueOf(array);
            BlockChunk.Vector chunkPosition = new BlockChunk.Vector(x, y, z);
            BlockChunk chunk = new BlockChunk(blockWorld, this, chunkPosition);
            chunk.setBits(bits);
            chunks.put(chunkPosition, chunk);
        }
    }

    void save() {
        List<Object> chunkList = new ArrayList<>();
        for (BlockChunk chunk: chunks.values()) {
            BitSet bits = chunk.getBits();
            if (bits.isEmpty()) continue;
            Map<String, Object> chunkMap = new HashMap<>();
            BlockChunk.Vector chunkPosition = chunk.getPosition();
            chunkMap.put("x", chunkPosition.getX());
            chunkMap.put("y", chunkPosition.getY());
            chunkMap.put("z", chunkPosition.getZ());
            chunkMap.put("v", bits.toLongArray());
            chunkList.add(chunkMap);
        }
        final YamlConfiguration yaml = new YamlConfiguration();
        yaml.set("chunks", chunkList);
        File dir = new File(blockWorld.getWorldFolder(), FOLDER);
        dir.mkdirs();
        final File file = new File(dir, getFileName());
        if (this.plugin.isEnabled()) {
            Bukkit.getScheduler().runTaskAsynchronously(this.plugin, () -> {
                    try {
                        yaml.save(file);
                    } catch (IOException ioe) {
                        ioe.printStackTrace();
                    }
                });
        } else {
            try {
                yaml.save(file);
            } catch (IOException ioe) {
                ioe.printStackTrace();
            }
        }
    }
}
