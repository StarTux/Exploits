package com.winthier.exploits;

import com.cavetale.core.event.block.PlayerChangeBlockEvent;
import com.cavetale.core.event.block.PluginBlockEvent;
import java.util.HashMap;
import java.util.Map;
import lombok.RequiredArgsConstructor;
import org.bukkit.Bukkit;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.NamespacedKey;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.block.BlockState;
import org.bukkit.block.data.BlockData;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.event.block.BlockBurnEvent;
import org.bukkit.event.block.BlockFormEvent;
import org.bukkit.event.block.BlockFromToEvent;
import org.bukkit.event.block.BlockGrowEvent;
import org.bukkit.event.block.BlockPistonExtendEvent;
import org.bukkit.event.block.BlockPistonRetractEvent;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.entity.EntityChangeBlockEvent;
import org.bukkit.event.entity.EntityExplodeEvent;
import org.bukkit.event.entity.EntitySpawnEvent;
import org.bukkit.event.player.PlayerBucketEmptyEvent;
import org.bukkit.event.player.PlayerBucketFillEvent;
import org.bukkit.event.world.StructureGrowEvent;
import org.bukkit.persistence.PersistentDataContainer;
import org.bukkit.persistence.PersistentDataType;

@RequiredArgsConstructor
final class PlayerPlacedBlocks implements Listener {
    private final ExploitsPlugin plugin;
    private Map<String, NamespacedKey> keyMap = new HashMap<>();

    protected boolean isPlayerPlaced(Block block) {
        Chunk chunk = block.getChunk();
        String stringKey = "" + (block.getY() >> 4);
        NamespacedKey key = keyMap.computeIfAbsent(stringKey, s -> new NamespacedKey(plugin, s));
        PersistentDataContainer container = chunk.getPersistentDataContainer();
        if (!container.has(key, PersistentDataType.LONG_ARRAY)) return false;
        long[] longArray = container.get(key, PersistentDataType.LONG_ARRAY);
        int bitIndex = Math.floorMod(block.getX(), 16)
            + (Math.floorMod(block.getY(), 16) << 8) // *256
            + (Math.floorMod(block.getZ(), 16) << 4); // *16
        int arrayIndex = bitIndex >> 6; // /64
        long bitSet = 1L << (bitIndex % 64);
        return (longArray[arrayIndex] & bitSet) != 0L;
    }

    protected void setPlayerPlaced(Block block, boolean value) {
        Chunk chunk = block.getChunk();
        String stringKey = "" + (block.getY() >> 4);
        NamespacedKey key = keyMap.computeIfAbsent(stringKey, s -> new NamespacedKey(plugin, s));
        PersistentDataContainer container = chunk.getPersistentDataContainer();
        final boolean has = container.has(key, PersistentDataType.LONG_ARRAY);
        if (!value && !has) return;
        long[] longArray = has
            ? container.get(key, PersistentDataType.LONG_ARRAY)
            : new long[64];
        int bitIndex = Math.floorMod(block.getX(), 16)
            + (Math.floorMod(block.getY(), 16) << 8) // *256
            + (Math.floorMod(block.getZ(), 16) << 4); // *16
        int arrayIndex = bitIndex >> 6; // /64
        long bitSet = 1L << (bitIndex % 64);
        if (value) {
            if (has && (longArray[arrayIndex] & bitSet) != 0L) return; // no change
            longArray[arrayIndex] |= bitSet;
            container.set(key, PersistentDataType.LONG_ARRAY, longArray);
            return;
        }
        // value == false!
        // has == true!
        if ((longArray[arrayIndex] & bitSet) == 0L) return; // no change
        longArray[arrayIndex] &= ~bitSet;
        if (!value) {
            // longArray might be empty!
            boolean hasBitsSet = false;
            for (int i = 0; i < longArray.length; i += 1) {
                if (longArray[i] != 0L) {
                    hasBitsSet = true;
                    break;
                }
            }
            if (!hasBitsSet) {
                container.remove(key);
                return;
            }
        }
        container.set(key, PersistentDataType.LONG_ARRAY, longArray);
    }

    public void setPlayerPlacedLater(Block block, boolean value) {
        plugin.getServer().getScheduler().runTask(plugin, () -> setPlayerPlaced(block, value));
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    private void onBlockPlace(BlockPlaceEvent event) {
        setPlayerPlaced(event.getBlock(), true);
        BlockData blockData = event.getBlock().getBlockData();
        if (blockData instanceof org.bukkit.block.data.Bisected) {
            switch (((org.bukkit.block.data.Bisected) blockData).getHalf()) {
            case BOTTOM:
                setPlayerPlaced(event.getBlock().getRelative(0, 1, 0), true);
                break;
            case TOP:
                setPlayerPlaced(event.getBlock().getRelative(0, -1, 0), true);
                break;
            default: break;
            }
        }
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    private void onBlockBreak(BlockBreakEvent event) {
        setPlayerPlaced(event.getBlock(), false);
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    private void onBlockFromTo(BlockFromToEvent event) {
        // Stone generators, for ores.
        if (event.getBlock().getType() == Material.LAVA
            && event.getToBlock().getType() == Material.WATER) {
            setPlayerPlaced(event.getToBlock(), true);
        }
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    private void onBlockForm(BlockFormEvent event) {
        if (event.getBlock().getType() == Material.WATER
            && event.getNewState().getType() == Material.STONE) {
            setPlayerPlaced(event.getBlock(), true);
        }
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    private void onBlockGrow(BlockGrowEvent event) {
        Block block = event.getBlock(); // Old block, I hope
        if (!block.isEmpty() && !block.isLiquid()) return;
        setPlayerPlaced(event.getBlock(), false);
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    private void onBlockBurn(BlockBurnEvent event) {
        setPlayerPlaced(event.getBlock(), false);
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    private void onStructureGrow(StructureGrowEvent event) {
        if (event.getBlocks().size() == 1) return;
        for (BlockState block : event.getBlocks()) {
            setPlayerPlaced(block.getBlock(), false);
        }
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    private void onBlockPistonExtend(BlockPistonExtendEvent event) {
        BlockFace direction = event.getDirection();
        for (Block block : event.getBlocks()) {
            setPlayerPlaced(block.getRelative(direction), true);
        }
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    private void onBlockPistonRetract(BlockPistonRetractEvent event) {
        BlockFace direction = event.getDirection();
        for (Block block : event.getBlocks()) {
            setPlayerPlaced(block.getRelative(direction), true);
        }
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    private void onEntityExplode(EntityExplodeEvent event) {
        for (Block block : event.blockList()) {
            setPlayerPlaced(block, false);
        }
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    private void onEntityChangeBlock(EntityChangeBlockEvent event) {
        if (event.getTo() == Material.AIR) {
            setPlayerPlaced(event.getBlock(), false);
        } else if (event.getTo() == Material.REDSTONE_ORE || event.getTo() == Material.DEEPSLATE_REDSTONE_ORE) {
            return;
        } else {
            setPlayerPlaced(event.getBlock(), true);
        }
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    private void onPlayerBucketEmpty(PlayerBucketEmptyEvent event) {
        setPlayerPlaced(event.getBlockClicked().getRelative(event.getBlockFace()), true);
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    private void onPlayerBucketFill(PlayerBucketFillEvent event) {
        setPlayerPlaced(event.getBlockClicked(), false);
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.LOWEST)
    private void onPluginBlock(PluginBlockEvent event) {
        if (event.getAction() == PluginBlockEvent.Action.NATURAL) {
            if (isPlayerPlaced(event.getBlock())) {
                event.setCancelled(true);
            }
        }
    }

    @EventHandler(priority = EventPriority.MONITOR)
    private void onPlayerChangeBlock(PlayerChangeBlockEvent event) {
        if (event.getNewBlockData().getMaterial().isAir()) {
            setPlayerPlaced(event.getBlock(), false);
        } else {
            setPlayerPlaced(event.getBlock(), true);
        }
    }

    protected void debug(Player player) {
        Chunk chunk = player.getChunk();
        final int min = chunk.getWorld().getMinHeight() >> 4;
        final int max = chunk.getWorld().getMaxHeight() >> 4;
        player.sendMessage("chunk=" + chunk.getX() + "," + chunk.getZ()
                           + " height=[" + min + "," + max + "]");
        PersistentDataContainer container = chunk.getPersistentDataContainer();
        for (int cy = max; cy >= min; cy -= 1) {
            String stringKey = "" + cy;
            NamespacedKey key = keyMap.computeIfAbsent(stringKey, s -> new NamespacedKey(plugin, s));
            if (container.has(key, PersistentDataType.LONG_ARRAY)) {
                long[] longArray = container.get(key, PersistentDataType.LONG_ARRAY);
                player.sendMessage(stringKey + ": long[" + longArray.length + "]");
            }
        }
    }

    /**
     * Replace bedrock that was placed as part of an end pillar respawn.
     */
    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    private void onEntitySpawn(EntitySpawnEvent event) {
        if (event.getEntityType() != EntityType.END_CRYSTAL) {
            return;
        }
        final Block block = event.getLocation().getBlock().getRelative(0, -1, 0);
        if (block.getType() == Material.BEDROCK) {
            return;
        }
        Bukkit.getScheduler().runTask(plugin, () -> {
                if (block.getType() != Material.BEDROCK) return;
                block.setType(Material.OBSIDIAN);
                setPlayerPlaced(block, true);
            });
    }
}
