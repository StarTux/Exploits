package com.winthier.exploits;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import lombok.RequiredArgsConstructor;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.block.BlockState;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.event.block.BlockBurnEvent;
import org.bukkit.event.block.BlockFormEvent;
import org.bukkit.event.block.BlockFromToEvent;
import org.bukkit.event.block.BlockGrowEvent;
import org.bukkit.event.block.BlockPistonExtendEvent;
import org.bukkit.event.block.BlockPistonRetractEvent;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.entity.EntityChangeBlockEvent;
import org.bukkit.event.entity.EntityExplodeEvent;
import org.bukkit.event.world.StructureGrowEvent;
import org.bukkit.event.world.WorldUnloadEvent;
import org.bukkit.scheduler.BukkitRunnable;

@RequiredArgsConstructor
public final class PlayerPlacedBlocks implements Listener {
    private final ExploitsPlugin plugin;
    private final Map<UUID, BlockWorld> worlds = new HashMap<>();
    private BukkitRunnable task;

    void onEnable() {
        task = new BukkitRunnable() {
                @Override public void run() {
                    regularCleanUp();
                }
            };
        task.runTaskTimer(plugin, 20L, 20L);
    }

    void onDisable() {
        task.cancel();
        for (BlockWorld world: worlds.values()) world.saveAll();
        worlds.clear();
    }

    private void regularCleanUp() {
        for (BlockWorld blockWorld: worlds.values()) {
            blockWorld.autoSaveAndGC();
        }
    }

    BlockWorld getBlockWorld(World world) {
        BlockWorld result = worlds.get(world.getUID());
        if (result == null) {
            result = new BlockWorld(world);
            worlds.put(world.getUID(), result);
        }
        return result;
    }

    BlockWorld getBlockWorld(Block block) {
        return getBlockWorld(block.getWorld());
    }

    public boolean isPlayerPlaced(Block block) {
        return getBlockWorld(block).isBlockSet(block);
    }

    public void setPlayerPlaced(Block block, boolean value) {
        getBlockWorld(block).setBlock(block, value);
    }

    @EventHandler
    public void onWorldUnload(WorldUnloadEvent event) {
        BlockWorld blockWorld = worlds.remove(event.getWorld().getUID());
        if (blockWorld != null) blockWorld.saveAll();
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onBlockPlace(BlockPlaceEvent event) {
        setPlayerPlaced(event.getBlock(), true);
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onBlockBreak(BlockBreakEvent event) {
        setPlayerPlaced(event.getBlock(), false);
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onBlockFromTo(BlockFromToEvent event) {
        // Stone generators, for ores.
        if (event.getBlock().getType() == Material.STATIONARY_LAVA
            && event.getToBlock().getType() == Material.STATIONARY_WATER) {
            setPlayerPlaced(event.getToBlock(), true);
        }
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onBlockForm(BlockFormEvent event) {
        switch (event.getBlock().getType()) {
        case WATER:
        case STATIONARY_WATER:
            if (event.getNewState().getType() == Material.STONE) setPlayerPlaced(event.getBlock(), true);
            break;
        case LAVA:
        case STATIONARY_LAVA:
            if (event.getNewState().getType() == Material.OBSIDIAN) setPlayerPlaced(event.getBlock(), true);
            break;
        default: break;
        }
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onBlockGrow(BlockGrowEvent event) {
        if (!event.getClass().equals(BlockGrowEvent.class)) return;
        setPlayerPlaced(event.getBlock(), false);
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onBlockBurn(BlockBurnEvent event) {
        setPlayerPlaced(event.getBlock(), false);
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onStructureGrow(StructureGrowEvent event) {
        for (BlockState block : event.getBlocks()) {
            setPlayerPlaced(block.getBlock(), false);
        }
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onBlockPistonExtend(BlockPistonExtendEvent event) {
        BlockFace direction = event.getDirection();
        for (Block block : event.getBlocks()) {
            setPlayerPlaced(block.getRelative(direction), true);
        }
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onBlockPistonRetract(BlockPistonRetractEvent event) {
        BlockFace direction = event.getDirection();
        for (Block block : event.getBlocks()) {
            setPlayerPlaced(block.getRelative(direction), true);
        }
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onEntityExplode(EntityExplodeEvent event) {
        for (Block block : event.blockList()) {
            setPlayerPlaced(block, false);
        }
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onEntityChangeBlock(EntityChangeBlockEvent event) {
        if (event.getTo() == Material.AIR) {
            setPlayerPlaced(event.getBlock(), false);
        } else if (event.getTo() == Material.GLOWING_REDSTONE_ORE) {
            return;
        } else {
            setPlayerPlaced(event.getBlock(), true);
        }
    }
}
