package com.winthier.exploits;

import java.io.File;
import java.sql.Blob;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// Legacy import
final class Legacy {
    static int migrateFrom(ExploitsPlugin plugin, String database, String user, String password) throws SQLException {
        String url = "jdbc:mysql://127.0.0.1:3306/" + database;
        try {
            Class.forName("com.mysql.jdbc.Driver");
        } catch (ClassNotFoundException cnfe) {
            cnfe.printStackTrace();
            return 0;
        }
        Connection connection = DriverManager.getConnection(url, user, password);
        Statement statement = connection.createStatement();
        String sql = "select w.name world, c.x x, c.y y, c.z z, b.data data from player_placed_blocks b join chunks c on b.chunk_id = c.id join worlds w on c.world_id = w.id";
        ResultSet result = statement.executeQuery(sql);
        Map<String, BlockWorld> worlds = new HashMap<>();
        int count = 0;
        while (result.next()) {
            String world = result.getString("world");
            int x = result.getInt("x");
            int y = result.getInt("y");
            int z = result.getInt("z");
            Blob blob = result.getBlob("data");
            byte[] bytes = blob.getBytes(1, (int)blob.length());
            BitSet bits = BitSet.valueOf(bytes);
            BlockWorld blockWorld = worlds.get(world);
            if (blockWorld == null) {
                blockWorld = new BlockWorld(new File(new File(plugin.getDataFolder(), "migrate"), world));
                blockWorld.getWorldFolder().mkdirs();
                worlds.put(world, blockWorld);
            }
            BlockChunk.Vector position = new BlockChunk.Vector(x, y, z);
            blockWorld.getBlockChunk(position).setBits(bits);
            blockWorld.getBlockChunk(position).getBlockRegion().setDirty(true);
            count += 1;
        }
        for (String worldName: worlds.keySet()) {
            BlockWorld blockWorld = worlds.get(worldName);
            List<BlockChunk> chunkList = new ArrayList<>();
            REGIONS:
            for (BlockRegion blockRegion: blockWorld.getRegions().values()) {
                for (BlockChunk blockChunk: blockRegion.getChunks().values()) {
                    chunkList.add(blockChunk);
                }
            }
            int correctedCount = 0;
            // The old version of Exploits had an off-by-one error in
            // its conversion from block coordinates to chunk
            // coordinates. As a result, for all chunks with a
            // negative X or Z coordinate, the layer of X=0 and Z=0
            // were offset by one chunk in the negative direction
            // along the respecive axis. The following attempts to fix
            // the problem as well as possible.
            //
            // ONCE
            Collections.sort(chunkList, new Comparator<BlockChunk>() {
                    @Override public int compare(BlockChunk a, BlockChunk b) {
                        return Integer.compare(b.getPosition().getZ(), a.getPosition().getZ());
                    }
                });
            CHUNKS:
            for (BlockChunk blockChunk: chunkList) {
                BlockChunk.Vector pos = blockChunk.getPosition();
                if (pos.getZ() > 0) continue CHUNKS;
                BlockChunk.Vector targetPos = new BlockChunk.Vector(pos.getX(), pos.getY(), pos.getZ() - 1);
                BlockChunk otherChunk = blockChunk.getBlockWorld().getBlockChunk(targetPos);
                for (int y = 0; y < 16; y += 1) {
                    for (int x = 0; x < 16; x += 1) {
                        blockChunk.setBlock(x, y, 0, otherChunk.isBlockSet(x, y, 0));
                    }
                }
                correctedCount += 1;
            }
            // REPEAT
            Collections.sort(chunkList, new Comparator<BlockChunk>() {
                    @Override public int compare(BlockChunk a, BlockChunk b) {
                        return Integer.compare(b.getPosition().getX(), a.getPosition().getX());
                    }
                });
            CHUNKS:
            for (BlockChunk blockChunk: chunkList) {
                BlockChunk.Vector pos = blockChunk.getPosition();
                if (pos.getX() > 0) continue CHUNKS;
                BlockChunk.Vector targetPos = new BlockChunk.Vector(pos.getX() - 1, pos.getY(), pos.getZ());
                BlockChunk otherChunk = blockChunk.getBlockWorld().getBlockChunk(targetPos);
                for (int y = 0; y < 16; y += 1) {
                    for (int z = 0; z < 16; z += 1) {
                        blockChunk.setBlock(0, y, z, otherChunk.isBlockSet(0, y, z));
                    }
                }
                correctedCount += 1;
            }
            // END REPEAT
            System.out.println(worldName + ": Corrected: " + correctedCount);
            blockWorld.saveAll();
        }
        return count;
    }
}
