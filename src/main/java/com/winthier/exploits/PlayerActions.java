package com.winthier.exploits;

import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.UUID;
import lombok.RequiredArgsConstructor;
import lombok.Value;
import org.bukkit.Location;
import org.bukkit.block.Block;
import org.bukkit.entity.Entity;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;
import org.bukkit.entity.Projectile;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.entity.EntityDeathEvent;
import org.bukkit.event.player.PlayerFishEvent;

@RequiredArgsConstructor
public final class PlayerActions implements Listener {
    private final ExploitsPlugin plugin;
    private final Map<UUID, Instance> players = new HashMap<>();

    @Value
    private static class Loc {
        private final String world;
        private final int x, y, z;
        private final long time;
        private static Loc of(Block block) {
            return new Loc(block.getWorld().getName(), block.getX(), block.getY(), block.getZ(), System.currentTimeMillis());
        }
        private static Loc of(Location loc) {
            return new Loc(loc.getWorld().getName(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ(), System.currentTimeMillis());
        }
    }

    private class Instance {
        private long time;
        private final LinkedList<Loc> brokenBlocks = new LinkedList<>();
        private final LinkedList<Loc> placedBlocks = new LinkedList<>();
        private final LinkedList<Loc> killedMobs = new LinkedList<>();
        private final LinkedList<Loc> caughtFish = new LinkedList<>();
    }

    Instance getInstance(Player player) {
        Instance result = players.get(player.getUniqueId());
        if (result == null) {
            result = new Instance();
            players.put(player.getUniqueId(), result);
        }
        result.time = System.currentTimeMillis();
        return result;
    }

    void cleanup(LinkedList<Loc> list) {
        long now = System.currentTimeMillis();
        for (Iterator<Loc> iter = list.iterator(); iter.hasNext();) {
            Loc loc = iter.next();
            if (loc.time + 60 * 60 * 1000 < now) {
                iter.remove();
            } else {
                return;
            }
        }
        for (Iterator<Instance> iter = players.values().iterator(); iter.hasNext();) {
            Instance inst = iter.next();
            if (inst.time + 60 * 60 * 1000 < now) iter.remove();
        }
    }

    boolean listContainsRecentBlock(LinkedList<Loc> list, Block block, long time) {
        long cutoff = System.currentTimeMillis() - time;
        String world = block.getWorld().getName();
        int x = block.getX(), y = block.getY(), z = block.getZ();
        for (Iterator<Loc> iter = list.descendingIterator(); iter.hasNext();) {
            Loc loc = iter.next();
            if (loc.time < cutoff) return false;
            if (!world.equals(loc.world)) continue;
            if (x != loc.x) continue;
            if (y != loc.y) continue;
            if (z != loc.z) continue;
            return true;
        }
        return false;
    }

    public boolean didRecentlyPlace(Player player, Block block, long seconds) {
        return listContainsRecentBlock(getInstance(player).placedBlocks, block, seconds * 1000);
    }

    public boolean didRecentlyBreak(Player player, Block block, long seconds) {
        return listContainsRecentBlock(getInstance(player).brokenBlocks, block, seconds * 1000);
    }

    public boolean didRecentlyFish(Player player, Block block, long seconds) {
        return listContainsRecentBlock(getInstance(player).caughtFish, block, seconds * 1000);
    }

    public double recentKillDistance(Player player, Location newKill, long seconds) {
        long cutoff = System.currentTimeMillis() - seconds * 1000;
        String world = newKill.getWorld().getName();
        int x = newKill.getBlockX(), y = newKill.getBlockY(), z = newKill.getBlockZ();
        int min = Integer.MAX_VALUE;
        for (Iterator<Loc> iter = getInstance(player).killedMobs.descendingIterator(); iter.hasNext();) {
            Loc loc = iter.next();
            if (loc.time < cutoff) break;
            if (!world.equals(loc.world)) continue;
            int dx = x - loc.x;
            int dy = y - loc.y;
            int dz = z - loc.z;
            int dist = dx * dx + dy * dy + dz * dz;
            if (dist < min) min = dist;
        }
        return Math.sqrt((double)min);
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onBlockBreak(BlockBreakEvent event) {
        Instance inst = getInstance(event.getPlayer());
        inst.brokenBlocks.add(Loc.of(event.getBlock()));
        cleanup(inst.brokenBlocks);
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onBlockPlace(BlockPlaceEvent event) {
        Instance inst = getInstance(event.getPlayer());
        inst.placedBlocks.add(Loc.of(event.getBlock()));
        cleanup(inst.placedBlocks);
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onEntityDeath(EntityDeathEvent event) {
        Player player = event.getEntity().getKiller();
        if (player == null) return;
        Instance inst = getInstance(player);
        inst.killedMobs.add(Loc.of(event.getEntity().getLocation()));
        cleanup(inst.killedMobs);
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onPlayerFish(PlayerFishEvent event) {
        switch (event.getState()) {
        case CAUGHT_FISH:
        case FAILED_ATTEMPT:
            break;
        default: return;
        }
        if (event.getCaught() == null) return;
        Instance inst = getInstance(event.getPlayer());
        inst.caughtFish.add(Loc.of(event.getCaught().getLocation()));
        cleanup(inst.caughtFish);
    }

    private Player getPlayerDamager(Entity damager) {
        if (damager instanceof Player) {
            return (Player)damager;
        } else if (damager instanceof Projectile) {
            Projectile projectile = (Projectile)damager;
            if (!(projectile.getShooter() instanceof Player)) return null;
            return (Player)projectile.getShooter();
        }
        return null;
    }

    private static final String DMG_KEY = "Winthier.PlayerDamage=";

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onEntityDamageByEntity(EntityDamageByEntityEvent event) {
        if (!(event.getEntity() instanceof LivingEntity)) return;
        final LivingEntity entity = (LivingEntity)event.getEntity();
        if (entity instanceof Player) return;
        Player player = getPlayerDamager(event.getDamager());
        if (player == null) return;
        final double dmg = event.getFinalDamage();
        String entry = null;
        if (!entity.isValid()) return;
        for (String tag: entity.getScoreboardTags()) {
            if (tag.startsWith(DMG_KEY)) {
                entry = tag;
                break;
            }
        }
        if (entry == null) {
            entity.addScoreboardTag(String.format("%s%f", DMG_KEY, dmg));
        } else {
            entity.removeScoreboardTag(entry);
            double old = Double.parseDouble(entry.substring(DMG_KEY.length()));
            entity.addScoreboardTag(String.format("%s%f", DMG_KEY, old + dmg));
        }
    }

    public double getPlayerDamage(Entity entity) {
        for (String tag: entity.getScoreboardTags()) {
            if (tag.startsWith(DMG_KEY)) {
                return Double.parseDouble(tag.substring(DMG_KEY.length()));
            }
        }
        return 0.0;
    }
}
