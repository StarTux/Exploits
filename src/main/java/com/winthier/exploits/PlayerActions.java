package com.winthier.exploits;

import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.UUID;
import lombok.RequiredArgsConstructor;
import lombok.Value;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.entity.Entity;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;
import org.bukkit.entity.Projectile;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.entity.EntityDeathEvent;
import org.bukkit.event.player.PlayerFishEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.metadata.FixedMetadataValue;
import org.bukkit.metadata.MetadataValue;

@RequiredArgsConstructor
public final class PlayerActions implements Listener {
    private final ExploitsPlugin plugin;
    private final Map<UUID, Instance> players = new HashMap<>();

    @Value
    private static class Loc {
        private final String world;
        private final int x, y, z;
        private final long time;
        private static Loc of(Block block) {
            return new Loc(block.getWorld().getName(), block.getX(), block.getY(), block.getZ(), System.currentTimeMillis());
        }
        private static Loc of(Location loc) {
            return new Loc(loc.getWorld().getName(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ(), System.currentTimeMillis());
        }
    }

    private class Instance {
        private long time;
        private final LinkedList<Loc> brokenBlocks = new LinkedList<>();
        private final LinkedList<Loc> placedBlocks = new LinkedList<>();
        private final LinkedList<Loc> killedMobs = new LinkedList<>();
        private final LinkedList<Loc> caughtFish = new LinkedList<>();
    }

    Instance getInstance(Player player) {
        Instance result = players.get(player.getUniqueId());
        if (result == null) {
            result = new Instance();
            players.put(player.getUniqueId(), result);
        }
        result.time = System.currentTimeMillis();
        return result;
    }

    void cleanup(LinkedList<Loc> list) {
        long now = System.currentTimeMillis();
        for (Iterator<Loc> iter = list.iterator(); iter.hasNext();) {
            Loc loc = iter.next();
            if (loc.time + 60 * 60 * 1000 < now) {
                iter.remove();
            } else {
                return;
            }
        }
        for (Iterator<Instance> iter = players.values().iterator(); iter.hasNext();) {
            Instance inst = iter.next();
            if (inst.time + 60 * 60 * 1000 < now) iter.remove();
        }
    }

    boolean listContainsRecentBlock(LinkedList<Loc> list, Block block, long time) {
        long cutoff = System.currentTimeMillis() - time;
        String world = block.getWorld().getName();
        int x = block.getX(), y = block.getY(), z = block.getZ();
        for (Iterator<Loc> iter = list.descendingIterator(); iter.hasNext();) {
            Loc loc = iter.next();
            if (loc.time < cutoff) return false;
            if (!world.equals(loc.world)) continue;
            if (x != loc.x) continue;
            if (y != loc.y) continue;
            if (z != loc.z) continue;
            return true;
        }
        return false;
    }

    public boolean didRecentlyPlace(Player player, Block block, long seconds) {
        return listContainsRecentBlock(getInstance(player).placedBlocks, block, seconds * 1000);
    }

    public boolean didRecentlyBreak(Player player, Block block, long seconds) {
        return listContainsRecentBlock(getInstance(player).brokenBlocks, block, seconds * 1000);
    }

    public boolean didRecentlyFish(Player player, Block block, long seconds) {
        long time = seconds * 1000;
        long cutoff = System.currentTimeMillis() - time;
        String world = block.getWorld().getName();
        int x = block.getX(), y = block.getY(), z = block.getZ();
        for (Iterator<Loc> iter = getInstance(player).caughtFish.descendingIterator(); iter.hasNext();) {
            Loc loc = iter.next();
            if (loc.time < cutoff) return false;
            if (!world.equals(loc.world)) continue;
            if (Math.abs(x - loc.x) > 1) continue;
            if (Math.abs(z - loc.z) > 1) continue;
            return true;
        }
        return false;
    }

    public double recentKillDistance(Player player, Location newKill, long seconds) {
        long cutoff = System.currentTimeMillis() - seconds * 1000;
        String world = newKill.getWorld().getName();
        int x = newKill.getBlockX(), y = newKill.getBlockY(), z = newKill.getBlockZ();
        int min = Integer.MAX_VALUE;
        for (Iterator<Loc> iter = getInstance(player).killedMobs.descendingIterator(); iter.hasNext();) {
            Loc loc = iter.next();
            if (loc.time < cutoff) break;
            if (!world.equals(loc.world)) continue;
            int dx = x - loc.x;
            int dy = y - loc.y;
            int dz = z - loc.z;
            int dist = dx * dx + dy * dy + dz * dz;
            if (dist < min) min = dist;
        }
        return Math.sqrt((double)min);
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onBlockBreak(BlockBreakEvent event) {
        Instance inst = getInstance(event.getPlayer());
        plugin.getServer().getScheduler().runTask(plugin, () -> inst.brokenBlocks.add(Loc.of(event.getBlock())));
        cleanup(inst.brokenBlocks);
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onBlockPlace(BlockPlaceEvent event) {
        Instance inst = getInstance(event.getPlayer());
        plugin.getServer().getScheduler().runTask(plugin, () -> inst.placedBlocks.add(Loc.of(event.getBlock())));
        cleanup(inst.placedBlocks);
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onEntityDeath(EntityDeathEvent event) {
        Player player = event.getEntity().getKiller();
        if (player == null) return;
        Instance inst = getInstance(player);
        plugin.getServer().getScheduler().runTask(plugin, () -> inst.killedMobs.add(Loc.of(event.getEntity().getLocation())));
        cleanup(inst.killedMobs);
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onPlayerFish(PlayerFishEvent event) {
        switch (event.getState()) {
        case CAUGHT_FISH:
        case FAILED_ATTEMPT:
            break;
        default: return;
        }
        Player player = event.getPlayer();
        Instance inst = getInstance(player);
        if (plugin.isDebug(player)) {
            Block block = player.getLocation().getBlock();
            player.sendMessage("[Exploits] Fish " + block.getX() + "," + block.getY() + "," + block.getZ() + " recent(5)=" + didRecentlyFish(player, block, 5));
        }
        plugin.getServer().getScheduler().runTask(plugin, () -> inst.caughtFish.add(Loc.of(player.getLocation())));
        cleanup(inst.caughtFish);
    }

    @EventHandler(ignoreCancelled = false, priority = EventPriority.MONITOR)
    public void onPlayerInteract(PlayerInteractEvent event) {
        switch (event.getAction()) {
        case RIGHT_CLICK_BLOCK:
            break;
        default:
            return;
        }
        ItemStack item = event.getItem();
        if (item == null || item.getType() != Material.FISHING_ROD) return;
        Player player = event.getPlayer();
        Instance inst = getInstance(player);
        Loc loc = Loc.of(player.getLocation());
        plugin.getServer().getScheduler().runTask(plugin, () -> inst.caughtFish.add(loc));
        if (plugin.isDebug(player)) {
            player.sendMessage("[Exploits] Fish Interact " + loc.x + "," + loc.y + "," + loc.z);
        }
    }

    private Player getPlayerDamager(Entity damager) {
        if (damager instanceof Player) {
            return (Player)damager;
        } else if (damager instanceof Projectile) {
            Projectile projectile = (Projectile)damager;
            if (!(projectile.getShooter() instanceof Player)) return null;
            return (Player)projectile.getShooter();
        }
        return null;
    }

    private static final String DMG_KEY = "Winthier.Exploits.PlayerDamage";

    @EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
    public void onEntityDamageByEntity(EntityDamageByEntityEvent event) {
        if (!(event.getEntity() instanceof LivingEntity)) return;
        final LivingEntity entity = (LivingEntity)event.getEntity();
        if (entity instanceof Player) return;
        Player player = getPlayerDamager(event.getDamager());
        if (player == null) return;
        final double dmg = event.getFinalDamage() + getPlayerDamage(entity);
        String entry = null;
        plugin.getServer().getScheduler().runTask(plugin, () -> {
                if (!entity.isValid()) return;
                entity.setMetadata(DMG_KEY, new FixedMetadataValue(plugin, dmg));
            });
    }

    public double getPlayerDamage(Entity entity) {
        for (MetadataValue meta: entity.getMetadata(DMG_KEY)) {
            if (meta.getOwningPlugin() == plugin) {
                return meta.asDouble();
            }
        }
        return 0.0;
    }
}
