package com.winthier.exploits;

import java.io.File;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.logging.Level;
import lombok.Value;
import org.bukkit.Bukkit;
import org.bukkit.Chunk;
import org.bukkit.NamespacedKey;
import org.bukkit.World;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.persistence.PersistentDataContainer;
import org.bukkit.persistence.PersistentDataType;
import org.bukkit.scheduler.BukkitRunnable;

final class Migrator {
    static final String FOLDER = "winthier.player_placed_blocks";

    private Migrator() { }

    protected static void migrate(ExploitsPlugin plugin) {
        List<Runnable> tasks = new ArrayList<>();
        List<World> worlds = Bukkit.getWorlds();
        for (int i = worlds.size() - 1; i >= 0; i -= 1) {
            World world = worlds.get(i);
            tasks.add(() -> migrate(plugin, world, tasks));
        }
        final long started = System.currentTimeMillis();
        new BukkitRunnable() {
            long lastLog;
            int done;
            @Override public void run() {
                if (tasks.isEmpty()) {
                    cancel();
                    plugin.getLogger().info("[Migrator] Finished: " + done);
                    return;
                }
                long now = System.currentTimeMillis();
                for (int i = 0; i < 10; i += 1) {
                    Runnable task = tasks.remove(tasks.size() - 1);
                    try {
                        task.run();
                        done += 1;
                    } catch (Exception e) {
                        plugin.getLogger().log(Level.SEVERE, "Stopping Migrator Task", e);
                        cancel();
                    }
                    if (tasks.isEmpty() || System.currentTimeMillis() - now >= 10L) break;
                }
                if (now - lastLog > 60000L) {
                    lastLog = now;
                    long seconds = (now - started - 1) / 1000L + 1L;
                    long tasksPerSecond = ((long) (done - 1)) / seconds + 1;
                    plugin.getLogger().info("[Migrator] Tasks: "
                                            + done + " done, "
                                            + tasks.size() + " queued, "
                                            + tasksPerSecond + " per second");
                }
            }
        }.runTaskTimer(plugin, 1L, 1L);
    }

    @Value
    static final class RegionFile {
        public final int x;
        public final int z;
        public final int order;
        public final File file;
    }

    protected static void migrate(ExploitsPlugin plugin, World world, List<Runnable> tasks) {
        File dir = new File(world.getWorldFolder(), FOLDER);
        if (!dir.isDirectory()) return;
        List<RegionFile> regionFiles = new ArrayList<>();
        for (File file : dir.listFiles()) {
            if (!file.isFile()) continue;
            String name = file.getName();
            if (!name.startsWith("region.")) throw new IllegalStateException(name + " startsWith");
            if (!name.endsWith(".yml")) throw new IllegalStateException(name + " endsWith");
            name = name.substring(7);
            name = name.substring(0, name.length() - 4);
            int dotIndex = name.indexOf(".");
            if (dotIndex < 0) throw new IllegalStateException(name + " dotIndex");
            final int x = Integer.parseInt(name.substring(0, dotIndex));
            final int z = Integer.parseInt(name.substring(dotIndex + 1));
            regionFiles.add(new RegionFile(x, z, Math.abs(x) + Math.abs(z), file));
        }
        Collections.sort(regionFiles, (a, b) -> Integer.compare(b.order, a.order));
        for (RegionFile r : regionFiles) {
            tasks.add(() -> migrate(plugin, world, r, tasks));
        }
        plugin.getLogger().info("[Migrator] " + world.getName() + ": " + regionFiles.size() + " region files");
    }

    @Value
    static final class Pair {
        public final int x;
        public final int z;
    }

    @Value
    static final class Cube {
        public final int x;
        public final int y;
        public final int z;
        public final BitSet bits;
    }

    /**
     * Migrate one region yml file.
     */
    protected static void migrate(ExploitsPlugin plugin, World world, RegionFile regionFile, List<Runnable> tasks) {
        YamlConfiguration yaml = YamlConfiguration.loadConfiguration(regionFile.file);
        Map<Pair, List<Cube>> cubeMap = new HashMap<>();
        for (Map<?, ?> chunkMap : yaml.getMapList("chunks")) {
            @SuppressWarnings("unchecked") final int x = (Integer) chunkMap.get("x");
            @SuppressWarnings("unchecked") final int y = (Integer) chunkMap.get("y");
            @SuppressWarnings("unchecked") final int z = (Integer) chunkMap.get("z");
            @SuppressWarnings("unchecked") final List<Number> longList = (List<Number>) chunkMap.get("v");
            long[] array = new long[longList.size()];
            for (int i = 0; i < array.length; i += 1) array[i] = longList.get(i).longValue();
            BitSet bits = BitSet.valueOf(array);
            cubeMap.computeIfAbsent(new Pair(x, z), p -> new ArrayList<>())
                .add(new Cube(x, y, z, bits));
        }
        for (Map.Entry<Pair, List<Cube>> entry : cubeMap.entrySet()) {
            Pair pair = entry.getKey();
            List<Cube> cubes = entry.getValue();
            tasks.add(() -> {
                    migrate(plugin, world, pair, cubes, tasks);
                });
        }
    }

    /**
     * Migrate one chunk column.
     */
    protected static void migrate(ExploitsPlugin plugin, World world, Pair pair, List<Cube> cubes, List<Runnable> tasks) {
        world.getChunkAtAsync(pair.x, pair.z, (Consumer<Chunk>) chunk -> {
                migrate(plugin, chunk, pair, cubes);
            });
    }

    /**
     * Migrate one chunk column. Scheduled via chunk load!
     */
    protected static void migrate(ExploitsPlugin plugin, Chunk chunk, Pair pair, List<Cube> cubes) {
        for (Cube cube : cubes) {
            NamespacedKey key = new NamespacedKey(plugin, "" + cube.y);
            PersistentDataContainer container = chunk.getPersistentDataContainer();
            final boolean has = container.has(key, PersistentDataType.LONG_ARRAY);
            long[] longArray = has
                ? container.get(key, PersistentDataType.LONG_ARRAY)
                : new long[64];
            for (int y = 0; y < 16; y += 1) {
                for (int z = 0; z < 16; z += 1) {
                    for (int x = 0; x < 16; x += 1) {
                        final int index = y * 16 * 16 + z * 16 + x;
                        if (!cube.bits.get(index)) continue;
                        int bitIndex = Math.floorMod(x, 16)
                            + (Math.floorMod(y, 16) << 8) // *256
                            + (Math.floorMod(z, 16) << 4); // *16
                        int arrayIndex = bitIndex >> 6; // /64
                        long bitSet = 1L << (bitIndex % 64);
                        longArray[arrayIndex] |= bitSet;
                    }
                }
            }
            container.set(key, PersistentDataType.LONG_ARRAY, longArray);
        }
    }
}
