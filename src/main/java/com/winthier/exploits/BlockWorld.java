package com.winthier.exploits;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.bukkit.World;
import org.bukkit.block.Block;

@Getter @RequiredArgsConstructor
class BlockWorld {
    private final File worldFolder;
    private final Map<BlockRegion.Vector, BlockRegion> regions = new HashMap<>();

    BlockWorld(World world) {
        this(world.getWorldFolder());
    }

    private BlockRegion getBlockRegion(BlockRegion.Vector position) {
        BlockRegion result = regions.get(position);
        if (result == null) {
            result = new BlockRegion(this, position);
            result.load();
            result.setLastSave(System.currentTimeMillis());
            regions.put(position, result);
        }
        return result;
    }

    BlockChunk getBlockChunk(BlockChunk.Vector position) {
        BlockRegion.Vector regionVector = BlockRegion.Vector.of(position);
        return getBlockRegion(regionVector).getBlockChunk(position);
    }

    private BlockChunk getBlockChunk(Block block) {
        return getBlockChunk(BlockChunk.Vector.of(block));
    }

    boolean isBlockSet(Block block) {
        BlockChunk chunk = getBlockChunk(block);
        chunk.getBlockRegion().setLastUsed(System.currentTimeMillis());
        return chunk.isBlockSet(block);
    }

    void setBlock(Block block, boolean value) {
        BlockChunk chunk = getBlockChunk(block);
        chunk.getBlockRegion().setLastUsed(System.currentTimeMillis());
        chunk.getBlockRegion().setDirty(true);
        chunk.setBlock(block, value);
    }

    void autoSaveAndGC() {
        long now = System.currentTimeMillis();
        for (BlockRegion region: new ArrayList<>(regions.values())) {
            if (region.isDirty() && region.getLastSave() + 1000 * 60 < now) {
                region.save();
                region.setDirty(false);
                region.setLastSave(now);
            }
            if (region.getLastUsed() + 1000 * 60 < now) {
                if (region.isDirty()) region.save();
                regions.remove(region.getPosition());
            }
        }
    }

    void saveAll() {
        for (BlockRegion region: new ArrayList<>(regions.values())) {
            if (region.isDirty()) {
                region.save();
            }
        }
    }
}
